#ifndef HLL_BYTECODE_H
#define HLL_BYTECODE_H

#include <stddef.h>
#include <stdint.h>

#include "hll_hololisp.h"

#define HLL_BYTECODE_MAX_CONSANT_COUNT UINT16_MAX

typedef enum {
  // Bytecode must be terminated with 0.
  HLL_BYTECODE_END = 0x0,
  // Pushes nil on stack
  HLL_BYTECODE_NIL,
  // Pushes true on stack
  HLL_BYTECODE_TRUE,
  // Pushes constant on stack (u16 index)
  HLL_BYTECODE_CONST,
  // Uses 3 last items on stack. First two are considered list head and tail,
  // 3 is element that needs to be appended to list. Pops last element
  // leaving only head and tail.
  // The reason for this instruction is to ease up creation of lists,
  // in favor of conses because the latter appear much rarer than lists.
  HLL_BYTECODE_APPEND,
  // Removes top element from stack
  HLL_BYTECODE_POP,
  // Does lookup of given symbol across all envs in lexical order.
  // Pushes on stack cons of variable storage (pair name-value).
  // Returning cons allows changing value in-place.
  HLL_BYTECODE_FIND,
  // Does context-sensitive call. Uses two elements on stack.
  // First is callable object. This is lisp object either a function (lambda)
  // or C binding. In first case creates new env and calls that function.
  HLL_BYTECODE_CALL,
  // Jump if true (i16 offset, two's complement).
  HLL_BYTECODE_JN,
  // Defines new variable with given name in current env (lexical env).
  // If variable with same name is defined in current env, error.
  // If variable with same name is defined in outer scope it is redefined in
  // current.
  HLL_BYTECODE_LET,
  // Creates new variable scope context. Used in let statements.
  // Form applications that feature manipulation of envs do it inline.
  HLL_BYTECODE_PUSHENV,
  // Removes last variable scope context. Used when leaving let statements
  HLL_BYTECODE_POPENV,
  // Returns car of top object on stack. If object is nil, return nil
  HLL_BYTECODE_CAR,
  // Returns cdr of top object on stack. If object is nil, return nil
  HLL_BYTECODE_CDR,
  // Sets car of 2-nd object on stack. Pops the value.
  HLL_BYTECODE_SETCAR,
  // Sets cdr of 2-nd object on stack. Pops the value.
  HLL_BYTECODE_SETCDR,
  // Creates function object using constant index (u16). Object in constant slot
  // should be compiled function object. It is copied and pushed on top of the
  // stack.
  // Then all symbols referenced in function definition are captured.
  HLL_BYTECODE_MAKEFUN,
  HLL_BYTECODE_DUP,
} hll_bytecode_op;

typedef struct hll_bytecode_location_entry {
  uint32_t translation_unit;
  size_t offset;
  uint32_t length;
} hll_bytecode_location_entry;

// Contains unit of bytecode. This is typically some compiled function
// with list of all variables referenced in it.
// Bytecode is reference counted in order to allow dynamic compilation and
// bytecode freeing, necessary in dynamic lisp environment.
typedef struct hll_bytecode {
  uint32_t refcount;
  // Bytecode dynamic array
  uint8_t *ops;
  // Constant pool dynamic array
  hll_value *constant_pool;
  // We encode information about source of the bytecode via RLE-encoded
  // array. Each RLE 64-bit entry consists of two 32-bit integers.
  // First integer is producer location, second is count of produced
  // instructions.
  // When executing some instruction fails, we do linear O(n) search in
  // RLE to find producer location. Location itself contains index of
  // translation unit, which VM can use to find file or string that was the
  // source for this generated bytecode.
  // Then debug system does linear O(n) search inside source string in order to
  // find line and column number.
  // All that information accompanied with one got from runtime system (call
  // stack, memory usage etc.) can be used to display user-friendly thorough
  // error message.
  hll_bytecode_location_entry *locs;
  uint64_t *loc_rle;
} hll_bytecode;

//
// Accessors
//

hll_bytecode *hll_new_bytecode(void);
void hll_bytecode_inc_refcount(hll_bytecode *bytecode);
void hll_bytecode_dec_refcount(hll_bytecode *bytecode);

//
// Functions used to generate bytecode
//

size_t hll_get_bytecode_op_body_size(hll_bytecode_op op);

size_t hll_bytecode_op_idx(hll_bytecode *bytecode);
size_t hll_bytecode_emit_u8(hll_bytecode *bytecode, uint8_t byte);
size_t hll_bytecode_emit_u16(hll_bytecode *bytecode, uint16_t value);
size_t hll_bytecode_emit_op(hll_bytecode *bytecode, hll_bytecode_op op);

//
// Debug routines
//

void hll_dump_bytecode(void *file, const hll_bytecode *bytecode);
void hll_dump_value(void *file, hll_value value);

#endif
