//
// hololisp public API definition.
//
#ifndef HLL_HOLOLISP_H
#define HLL_HOLOLISP_H

#include <setjmp.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>

#ifdef HLL_DEBUG
#if defined(__GNUC__) || defined(__clang__)
#define HLL_UNREACHABLE __builtin_trap()
#else
#error Not implemented
#endif
#else // HLL_DEBUG
#if defined(__GNUC__) || defined(__clang__)
#define HLL_UNREACHABLE __builtin_unreachable()
#else
#error Not implemented
#endif
#endif // HLL_DEBUG

// Stretchy buffer
// This is implementation of type-safe generic vector in C based on
// std_stretchy_buffer.
typedef struct {
  size_t size;
  size_t capacity;
} hll_sb_header;

struct hll_vm;

// This function is responsible for providing error output to user.
typedef void hll_error_fn(struct hll_vm *vm, const char *text);

// Function that is used in 'print' statements.
typedef void hll_write_fn(struct hll_vm *vm, const char *text);

typedef struct {
  // The callback used when user prints message (printf for example).
  // If this is NULL, nothing shall be printed.
  hll_write_fn *write_fn;

  // THe callback used when error is reported.
  // If this is NULL, nothing happens.
  hll_error_fn *error_fn;

  // Initial size of head before first garbage collection.
  // Default value is 10MB
  size_t heap_size;

  // After garbage collection, heap is resized to automatically adjust to
  // amount of memory used. If heap size gets too small, garbage collections
  // may occur more often, Which is not desirable. This value sets minimal
  // possible size for heap.
  // Default value is 1MB
  size_t min_heap_size;

  // After garbage collection the next heap size that should trigger garbage
  // collections is set. This value describes size of heap that should
  // trigger next garbage collection in percent of current size.
  // Default value is 50
  size_t heap_grow_percent;

  // Any data user wants to be accessed through callback functions.
  void *user_data;
} hll_config;

#define HLL_CALL_STACK_SIZE 1024
#define HLL_STACK_SIZE (1024 * 1024)

// Type of 'value' in language. By 'value' we understand minimal unit of
// language that interpreter can operate on. 'values' can be, for example,
// numbers, conses, symbols.
typedef uint64_t hll_value;

// Bytecode contains source location in order to provide meaningful error
// messages. This information is encoded in run-length encoding based format.
// This structure describes unit of rle encoding, specifying locations for
// next 'length' operands.
typedef struct {
  uint32_t length;
  uint32_t loc_idx;
} hll_bytecode_rle;

// Debug Translation Unit.
typedef struct {
  const char *source;
  const char *name;
  // We encode information about source of the bytecode via RLE-encoded
  // array. Each RLE 64-bit entry consists of two 32-bit integers.
  // First integer is producer location, second is count of produced
  // instructions.
  // When executing some instruction fails, we do linear O(n) search in
  // RLE to find producer location. Location itself contains index of
  // translation unit, which VM can use to find file or string that was the
  // source for this generated bytecode.
  // Then debug system does linear O(n) search inside source string in order to
  // find line and column number.
  // All that information accompanied with one got from runtime system (call
  // stack, memory usage etc.) can be used to display user-friendly thorough
  // error message.
  struct hll_loc *locs;
  hll_bytecode_rle *loc_rle;
} hll_dtu;

typedef struct hll_gc {
  // backpointer to vm. Although it creates circular reference,
  // it is unavoidable in cotext of vm. GC is deeply integrated into VM runtime,
  // su separating them would be unreasanoble.
  struct hll_vm *vm;

  // Linked list of all objects.
  struct hll_obj *all_objs;
  // Count all allocated bytes to know when to trigger garbage collection.
  size_t bytes_allocated;
  // If bytes_allocated becomes greater than this value, trigger next gc.
  // May not be greater than min_heap_size specified in config.
  size_t next_gc;
  hll_value *gray_objs;
  hll_value temp_roots_storage[HLL_CALL_STACK_SIZE];
  hll_value *temp_roots;
  uint32_t forbid;
} hll_gc;

typedef struct {
  struct hll_vm *vm;

  hll_dtu *dtus;
  uint32_t flags;

  uint32_t error_count;
} hll_meta_storage;

typedef struct {
  const struct hll_bytecode *bytecode;
  const uint8_t *ip;
  hll_value env;
  hll_value func;
} hll_call_frame;

typedef struct hll_vm {
  hll_config config;
  hll_meta_storage *debug;
  hll_gc *gc;

  // We use xorshift64 for random number generation. Because hololisp is
  // single-threaded, we can use single global variable for rng state.
  uint64_t rng_state;

  // Global env. It is stored across calls to interpret, allowing defining
  // toplevel functions.
  hll_value global_env;
  hll_value macro_env;

  // Current execution state
  hll_value *stack_bottom;
  hll_value *stack;
  hll_call_frame *call_stack_bottom;
  hll_call_frame *call_stack;
  hll_value env;

  jmp_buf err_jmp;
} hll_vm;

typedef struct hll_loc {
  uint32_t translation_unit;
  uint32_t offset;
} hll_loc;

enum {
  // Print result of execution. This may be needed depending on context:
  // for example, when execution REPL result print is needed, while when
  // executing files this is unwanted.
  HLL_INTERPRET_PRINT_RESULT = 0x1,
  // Make output of error messages be colored using ANSI escape codes.
  HLL_INTERPRET_COLORED = 0x2
};

enum {
  HLL_DEBUG_DIAGNOSTICS_COLORED = 0x1,
};

typedef enum {
  HLL_EXPAND_MACRO_OK,
  HLL_EXPAND_MACRO_ERR_ARGS
} hll_expand_macro_result;

typedef enum {
  // Bytecode must be terminated with 0. This means return from currently
  // executed function and go up call stack
  HLL_BC_END,
  // Pushes nil on stack
  HLL_BC_NIL,
  // Pushes true on stack
  HLL_BC_TRUE,
  // Pushes constant on stack (u16 index)
  HLL_BC_CONST,
  // Uses 3 last items on stack. First two are considered list head and tail,
  // 3 is element that needs to be appended to list. Pops last element
  // leaving only head and tail.
  // The reason for this instruction is to ease up creation of lists,
  // in favor of conses because the latter appears much rarer than lists.
  HLL_BC_APPEND,
  // Removes top element from stack
  HLL_BC_POP,
  // Does lookup of given symbol across all envs in lexical order.
  // Pushes on stack cons of variable storage (pair name-value).
  // Returning cons allows changing value in-place.
  HLL_BC_FIND,
  // Does context-sensitive call. Uses two elements on stack.
  // First is callable object. This is lisp object either a function (lambda)
  // or C binding. In first case creates new env and calls that function.
  HLL_BC_CALL,
  // Maybe tail recursive call. Compiler marks calls that are tail-ones,
  // and when vm sees this instruction it possibly do self tail recursion.
  HLL_BC_MBTRCALL,
  // Jump if nil (u16 offset, two's complement).
  HLL_BC_JN,
  // Defines new variable with given name in current env (lexical env).
  // If variable with same name is defined in current env, error.
  // If variable with same name is defined in outer scope it is redefined in
  // current.
  HLL_BC_LET,
  // Creates new variable scope context. Used in let statements.
  // Form applications that feature manipulation of envs do it inline.
  HLL_BC_PUSHENV,
  // Removes last variable scope context. Used when leaving let statements
  HLL_BC_POPENV,
  // Returns car of top object on stack. If object is nil, return nil
  HLL_BC_CAR,
  // Returns cdr of top object on stack. If object is nil, return nil
  HLL_BC_CDR,
  // Sets car of 2-nd object on stack. Pops the value.
  HLL_BC_SETCAR,
  // Sets cdr of 2-nd object on stack. Pops the value.
  HLL_BC_SETCDR,
  // Creates function object using constant index (u16). Object in constant slot
  // should be compiled function object. It is copied and pushed on top of the
  // stack.
  // Then all symbols referenced in function definition are captured.
  HLL_BC_MAKEFUN,
} hll_bytecode_op;

// Contains unit of bytecode. This is typically some compiled function
// with list of all variables referenced in it.
// Bytecode is reference counted in order to allow dynamic compilation and
// bytecode freeing, necessary in dynamic lisp environment.
typedef struct hll_bytecode {
  uint32_t refcount;
  // Bytecode dynamic array
  uint8_t *ops;
  // Constant pool dynamic array
  hll_value *constant_pool;
  uint32_t translation_unit;
  // Name string object. It needs to be hololisp object because it comes from
  // AST.
  hll_value name;
} hll_bytecode;

// Result of calling hll_interpret.
// Contains minimal information about source of error.
typedef enum {
  HLL_RESULT_OK = 0x0,
  HLL_RESULT_ERROR = 0x1,
} hll_interpret_result;

typedef struct hll_obj {
  uint8_t kind;
  bool is_dark;
  struct hll_obj *next_gc;
  char as[];
} hll_obj;

typedef struct hll_obj_cons {
  hll_value car;
  hll_value cdr;
} hll_obj_cons;

typedef struct hll_obj_func {
  struct hll_bytecode *bytecode;
  hll_value param_names;
  hll_value env;
} hll_obj_func;

typedef struct hll_obj_env {
  hll_value vars;
  hll_value up;
} hll_obj_env;

typedef struct hll_obj_bind {
  hll_value (*bind)(struct hll_vm *vm, hll_value args);
} hll_obj_bind;

typedef struct hll_obj_symb {
  uint32_t length;
  uint32_t hash;
  char symb[];
} hll_obj_symb;

enum {
  // Singleton values. These are not heap-allocated.
  HLL_VALUE_NUM = 0x0,
  HLL_VALUE_NIL = 0x1,
  HLL_VALUE_TRUE = 0x2,
  // Heap-allocated garbage-collected values
  HLL_VALUE_CONS = 0x3,
  HLL_VALUE_SYMB = 0x4,
  HLL_VALUE_BIND = 0x5,
  HLL_VALUE_ENV = 0x6,
  HLL_VALUE_FUNC = 0x7,
};

#define HLL_LOCATION_TABLE_SIZE 8192

// Describes entry of location table.
typedef struct {
  size_t next;
  uint64_t hash;
  // We store location information as offsets instead of line + column to speed
  // up lexing. This differs from textbook approach.
  size_t offset;
  uint32_t length;
} hll_location_entry;

// Table of locations used during compilation. Because of the nature of lisp,
// we want to allow using values from language to be used directly as AST,
// which makes embedding location info into values undesirable because
// of memory waste in most use cases.
// Instead, during compilation we create table of location infos,
// where each create object is mapped to its location using hash table
// which uses object pointers as hash values.
// Table is deleted just after the compilation finishes,
// using information from it to build mapping for bytecode instructions to
// source locations.
typedef struct {
  size_t hash_table[HLL_LOCATION_TABLE_SIZE];
  hll_location_entry *entries;
} hll_location_table;

// Flags of translation unit.
enum { HLL_TU_FLAG_DEBUG = 0x1 };

// Meta information used during compilation.
typedef struct {
  // Index of compilation unit in global table.
  uint32_t translation_unit;
  // Pointer to location table. Location table is populated during parsing,
  // and information stored in it is later used when building bytecode.
  hll_location_table *locs;
  const char *name;
  const char *source;
  struct hll_vm *vm;
  uint32_t flags;
} hll_translation_unit;

// Kinds of tokens recognized by lexer.
typedef enum {
  HLL_TOK_EOF,
  HLL_TOK_NUM,
  HLL_TOK_SYMB,
  HLL_TOK_DOT,
  HLL_TOK_LPAREN,
  HLL_TOK_RPAREN,
  HLL_TOK_QUOTE,
  HLL_TOK_COMMENT,
  HLL_TOK_UNEXPECTED
} hll_token_kind;

// Token generated as result of lexing.
typedef struct {
  hll_token_kind kind;
  // offset from start of file. Can be used to generate line information
  size_t offset;
  // length of token in bytes
  uint32_t length;
  // Value of token if it is a number
  double value;
} hll_token;

// Lexer is designed in way it is possible to use outside of compiler to allow
// asy writing of tools like syntax highlighter and code formatter.
// Thus is does not act as a individual step of translation but as
// helper for reader.
typedef struct {
  // Used for error reporting. If NULL, no errors are reported
  hll_translation_unit *tu;
  // Mark that errors have been encountered during lexing.
  uint32_t error_count;
  // Current parsing location
  const char *cursor;
  // Input start. Used to calculate each token's offset
  const char *input;
  // Next peeked token. Stores result of lexing
  hll_token next;
} hll_lexer;

typedef struct {
  uint32_t cu;
  uint32_t offset;
  uint32_t length;
} hll_compiler_loc_stack_entry;

// Structure that holds state of compiler.
typedef struct {
  uint32_t error_count;

  // Bytecode that is currently being generated.
  struct hll_bytecode *bytecode;

  // Stack of locations compiler maintains. It is used to generate RLE-encoded
  // location information embedded in bytecode.
  hll_compiler_loc_stack_entry *loc_stack;
  // Compilation unit information. This decides whether to add location
  // information to generated bytecode or not.
  hll_translation_unit *tu;
  // Counter of first insruction in current RLE group (instructions that refer
  // to same location). It is updated when the loc_stack is changed.
  size_t loc_op_idx;
} hll_compiler;


#define hll_sb_header(_a)                                                      \
  ((hll_sb_header *)((char *)(_a) - sizeof(hll_sb_header)))
#define hll_sb_size(_a) (hll_sb_header(_a)->size)
#define hll_sb_capacity(_a) (hll_sb_header(_a)->capacity)

#define hll_sb_needgrow(_a, _n)                                                \
  (((_a) == NULL) || (hll_sb_size(_a) + (_n) >= hll_sb_capacity(_a)))
#define hll_sb_maybegrow(_a, _n)                                               \
  (hll_sb_needgrow(_a, _n) ? hll_sb_grow(_a, _n) : 0)
#define hll_sb_grow(_a, _b)                                                    \
  (*(void **)(&(_a)) = hll_sb_grow_impl((_a), (_b), sizeof(*(_a))))

#define hll_sb_free(_a)                                                        \
  (((_a) != NULL)                                                              \
   ? hll_free(hll_sb_header(_a),                                               \
              hll_sb_capacity(_a) * sizeof(*(_a)) + sizeof(hll_sb_header)),    \
   0 : 0)
#define hll_sb_push(_a, _v)                                                    \
  (hll_sb_maybegrow(_a, 1), (_a)[hll_sb_size(_a)++] = (_v))
#define hll_sb_last(_a) ((_a)[hll_sb_size(_a) - 1])
#define hll_sb_len(_a) (((_a) != NULL) ? hll_sb_size(_a) : 0)
#define hll_sb_pop(_a) ((_a)[--hll_sb_size(_a)])
#define hll_sb_purge(_a) ((_a) ? (hll_sb_size(_a) = 0) : 0)

void *hll_sb_grow_impl(void *arr, size_t inc, size_t stride);

#define hll_free(_ptr, _size) (void)hll_realloc(_ptr, _size, 0)
#define hll_alloc(_size) hll_realloc(NULL, 0, _size)

// realloc that hololisp uses for all memory allocations internally.
// If new_size is 0, behaves as 'free'.
// If old_size is 0, behaves as 'calloc'
// Otherwise behaves as 'realloc'
void *hll_realloc(void *ptr, size_t old_size, size_t new_size)
    __attribute__((alloc_size(3)));

#define HLL_CALL_STACK_SIZE 1024
#define HLL_STACK_SIZE (1024 * 1024)

void hll_initialize_default_config(hll_config *config);


// If config is NULL, uses default config.
// Config is copied to the VM.
hll_vm *hll_make_vm(const hll_config *config);

// Deletes VM and frees all its data.
void hll_delete_vm(hll_vm *vm) __attribute__((nonnull));

// Runs given source as hololisp code.
hll_interpret_result hll_interpret(hll_vm *vm, const char *source,
                                   const char *name, uint32_t flags)
    __attribute__((nonnull));

hll_meta_storage *hll_make_debug(struct hll_vm *vm, uint32_t flags);
void hll_delete_debug(hll_meta_storage *ds);
void hll_reset_debug(hll_meta_storage *ds);

uint32_t hll_ds_init_tu(hll_meta_storage *ds, const char *source,
                        const char *name);

// Used to report error in current state contained by vm.
// vm must have current_filename field present if message needs to include
// source location.
// offset specifies byte offset of reported location in file.
// len specifies length of reported part (e.g. token).
void hll_report_errorv(hll_meta_storage *debug, hll_loc loc, const char *fmt,
                       va_list args);
void hll_report_error(hll_meta_storage *debug, hll_loc loc, const char *fmt,
                      ...) __attribute__((format(printf, 3, 4)));

void hll_report_runtime_errorv(hll_meta_storage *debug, const char *fmt,
                               va_list args);

void hll_debug_print_summary(hll_meta_storage *debug);

void hll_bytecode_add_loc(hll_meta_storage *debug, uint32_t tu,
                          size_t op_length, uint32_t compilation_unit,
                          uint32_t offset);
uint32_t hll_bytecode_get_loc(hll_meta_storage *debug, uint32_t tu,
                              size_t op_idx);

void hll_add_binding(hll_vm *vm, const char *symb,
                     hll_value (*bind)(hll_vm *vm, hll_value args));

hll_interpret_result hll_interpret_bytecode(hll_vm *vm, hll_value compiled,
                                            bool print_result);

void hll_add_variable(hll_vm *vm, hll_value env, hll_value name,
                      hll_value value);

hll_expand_macro_result hll_expand_macro(hll_vm *vm, hll_value macro,
                                         hll_value args, hll_value *dst);

void hll_print_value(hll_vm *vm, hll_value obj);

bool hll_find_var(hll_value env, hll_value car, hll_value *found);

__attribute__((format(printf, 2, 3))) void
hll_runtime_error(hll_vm *vm, const char *fmt, ...);

hll_value hll_interpret_bytecode_internal(hll_vm *vm, hll_value env_,
                                          hll_value compiled);

void hll_print(hll_vm *vm, const char *str);

//
// Accessor overriding functions. By lisp standards, car returns car of object
// if object is cons, nil if object is nil and panics otherwise.
//

hll_value hll_car(hll_vm *vm, hll_value lis);
hll_value hll_cdr(hll_vm *vm, hll_value lis);


//
// Accessors
//

hll_bytecode *hll_new_bytecode(hll_value name);
void hll_bytecode_inc_refcount(hll_bytecode *bytecode);
void hll_bytecode_dec_refcount(hll_bytecode *bytecode);

//
// Functions used to generate bytecode
//

size_t hll_bytecode_op_idx(const hll_bytecode *bytecode);
size_t hll_bytecode_emit_u8(hll_bytecode *bytecode, uint8_t byte);
size_t hll_bytecode_emit_u16(hll_bytecode *bytecode, uint16_t value);
size_t hll_bytecode_emit_op(hll_bytecode *bytecode, hll_bytecode_op op);

void hll_optimize_bytecode(hll_bytecode *bytecode);

//
// Debug routines
//

void hll_dump_program_info(void *file, hll_value program);
void hll_dump_bytecode(void *file, const hll_bytecode *bytecode);
void hll_dump_value(void *file, hll_value value);

const char *hll_value_kind_str_(uint8_t kind);
const char *hll_value_kind_str(hll_value value);

//
// Functions that create new values.
//

hll_value hll_new_symbol(struct hll_vm *vm, const char *symbol, size_t length);
hll_value hll_new_symbolz(struct hll_vm *vm, const char *symbol);
hll_value hll_new_cons(struct hll_vm *vm, hll_value car, hll_value cdr);
hll_value hll_new_env(struct hll_vm *vm, hll_value up, hll_value vars);
hll_value hll_new_bind(struct hll_vm *vm,
                       hll_value (*bind)(struct hll_vm *vm, hll_value args));
hll_value hll_new_func(struct hll_vm *vm, hll_value params,
                       struct hll_bytecode *bytecode);

void hll_free_obj(struct hll_vm *vm, hll_obj *obj);

size_t hll_list_length(hll_value value);

#define HLL_SIGN_BIT ((uint64_t)1 << 63)
#define HLL_QNAN ((uint64_t)0x7ffc000000000000)

static inline hll_value nan_box_singleton(uint8_t kind) {
  return HLL_QNAN | kind;
}

static inline uint8_t nan_unbox_singleton(hll_value value) {
  return value & ~(HLL_QNAN);
}

static inline hll_value nan_box_ptr(void *ptr) {
  return ((uintptr_t)ptr) | (HLL_SIGN_BIT | HLL_QNAN);
}

static inline hll_obj *nan_unbox_ptr(hll_value value) {
  return (hll_obj *)(uintptr_t)(value & ~(HLL_SIGN_BIT | HLL_QNAN));
}

static inline hll_value hll_nil(void) {
  return nan_box_singleton(HLL_VALUE_NIL);
}
static inline hll_value hll_true(void) {
  return nan_box_singleton(HLL_VALUE_TRUE);
}
static inline hll_value hll_num(double num) {
  hll_value value;
  memcpy(&value, &num, sizeof(hll_value));
  return value;
}

static inline bool hll_is_num(hll_value value) {
  return (value & HLL_QNAN) != HLL_QNAN;
}
static inline bool hll_is_obj(hll_value value) {
  return (((value) & (HLL_QNAN | HLL_SIGN_BIT)) == (HLL_QNAN | HLL_SIGN_BIT));
}
static inline uint8_t hll_value_kind(hll_value value) {
  return hll_is_obj(value) ? nan_unbox_ptr(value)->kind
                           : nan_unbox_singleton(value);
}

static inline bool hll_is_nil(hll_value value) { return value == hll_nil(); }

static inline bool hll_is_cons(hll_value value) {
  return hll_is_obj(value) && nan_unbox_ptr(value)->kind == HLL_VALUE_CONS;
}

static inline bool hll_is_symb(hll_value value) {
  return hll_is_obj(value) && nan_unbox_ptr(value)->kind == HLL_VALUE_SYMB;
}

static inline bool hll_is_list(hll_value value) {
  return hll_is_cons(value) || hll_is_nil(value);
}

static inline hll_obj_cons *hll_unwrap_cons(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_CONS);
  return (hll_obj_cons *)obj->as;
}

static inline const char *hll_unwrap_zsymb(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_SYMB);
  return ((hll_obj_symb *)obj->as)->symb;
}

static inline hll_obj_symb *hll_unwrap_symb(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_SYMB);
  return (hll_obj_symb *)obj->as;
}

static inline hll_value hll_unwrap_cdr(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_CONS);
  return ((hll_obj_cons *)obj->as)->cdr;
}

static inline hll_value hll_unwrap_car(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_CONS);
  return ((hll_obj_cons *)obj->as)->car;
}

static inline hll_obj_bind *hll_unwrap_bind(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_BIND);
  return (hll_obj_bind *)obj->as;
}

static inline hll_obj_env *hll_unwrap_env(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_ENV);
  return (hll_obj_env *)obj->as;
}

static inline hll_obj_func *hll_unwrap_func(hll_value value) {
  assert(hll_is_obj(value));
  hll_obj *obj = nan_unbox_ptr(value);
  assert(obj->kind == HLL_VALUE_FUNC);
  return (hll_obj_func *)obj->as;
}

static inline double hll_unwrap_num(hll_value value) {
  assert(hll_is_num(value));
  double result;
  memcpy(&result, &value, sizeof(hll_value));
  return result;
}

static inline hll_obj *hll_unwrap_obj(hll_value value) {
  assert(hll_is_obj(value));
  return nan_unbox_ptr(value);
}

static inline void hll_setcar(hll_value cons, hll_value car) {
  hll_unwrap_cons(cons)->car = car;
}

static inline void hll_setcdr(hll_value cons, hll_value cdr) {
  hll_unwrap_cons(cons)->cdr = cdr;
}

hll_translation_unit hll_make_tu(struct hll_vm *vm, const char *source,
                                 const char *name, uint32_t flags);
void hll_delete_tu(hll_translation_unit *tu);

void hll_lexer_init(hll_lexer *lexer, const char *input,
                    hll_translation_unit *tu) __attribute__((nonnull));

// Generate next token and return it. If EOF is reached, EOF token is
// guaranteed to always be returned after that.
const hll_token *hll_lexer_next(hll_lexer *lexer) __attribute__((nonnull));

// Reader that generates AST using tokens generated by lexer. This structure
// is also commonly known as parser.
typedef struct {
  // Needed for error reporting and object allocations.
  hll_translation_unit *tu;
  // Mark that errors have been encountered during parsing.
  uint32_t error_count;
  // Lexer used for reading.
  // Reader process all tokens produced by lexer until EOF, so lifetime of
  // this lexer is associated with reader.
  hll_lexer *lexer;
  // Last token generated by lexer. This is shortcut not to access it through
  // lexer every time. This is pointer to 'next' field of lexer.
  const hll_token *token;
  // Internal flag used in lexer. Used for generating 'peek-eat' workflow
  // during reading.
  bool should_return_old_token;
} hll_reader;

// Initialized reader to use given lexer. Lexer is taken as pointer to allow
// used decide where it comes from.
void hll_reader_init(hll_reader *reader, hll_lexer *lexer,
                     hll_translation_unit *tu) __attribute__((nonnull));

// Reads whole ast tree.
hll_value hll_read_ast(hll_reader *reader) __attribute__((nonnull));

void hll_compiler_init(hll_compiler *compiler, hll_translation_unit *tu,
                       hll_value name) __attribute__((nonnull));

// Compiles ast into a function object. Garbage collection is forbidden to
// happen during execution of this function.
hll_value hll_compile_ast(hll_compiler *compiler, hll_value ast)
    __attribute__((nonnull));

// Compiles hololisp code as a hololisp bytecode.
// Returns true on success, false otherwise.
// writes resulting function to location pointed by 'compiled' parameter.
// If function does not success, contents of memory pointed by 'compiled'
// are not defined.
bool hll_compile(struct hll_vm *vm, const char *source, const char *name,
                 hll_value *compiled) __attribute__((nonnull));

hll_gc *hll_make_gc(struct hll_vm *vm);
void hll_delete_gc(hll_gc *gc);

void hll_push_forbid_gc(hll_gc *gc);
void hll_pop_forbid_gc(hll_gc *gc);

void hll_gc_push_temp_root(hll_gc *gc, hll_value value);
void hll_gc_pop_temp_root(hll_gc *gc);

// Garbage collector tracked allocation
#define hll_gc_free(_vm, _ptr, _size) hll_gc_realloc(_vm, _ptr, _size, 0)
#define hll_gc_alloc(_vm, _size) hll_gc_realloc(_vm, NULL, 0, _size)
void *hll_gc_realloc(hll_gc *gc, void *ptr, size_t old_size, size_t new_size)
    __attribute__((alloc_size(4)));

#endif
