//
// hll_compiler.h
//
// This file contains lexer, parser and compiler definitions for use with
// hololisp. This is probably the largest unit in a codebase but there is no
// attempts to split it because its parts are interviened and spliiting them
// will make understanding more complex.
//
// The only API for public usage is hll_compile, which takes source string and
// produces hololisp bytecode output.
//
// Lexer accepts c string of input and produces sequence of tokens.
// Lexer uses FSM internally and is able to generate tokens on demand
// one-by-one.
//
// Parser uses naive recursive-descent algorithm and produces tree of lisp
// objects, like lists.
//
// Compiler takes tree of tokens that can either be result of parsing or come
// from some other source, like be result of compilation.
// Compiler produces lisp function object that contains compiled lisp code
// generated from input.
//
// Despite lexer and parser being embedded and used only in intermediate
// step before compiling, they are made public for more usability.
//
#ifndef HLL_COMPILER_H
#define HLL_COMPILER_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "hll_hololisp.h"

#define HLL_LOCATION_TABLE_SIZE 8192

// Describes entry of location table.
typedef struct {
  size_t next;
  uint64_t hash;
  // We store location information as offsets instead of line + column to speed
  // up lexing. This differs from textbook approach.
  size_t offset;
  uint32_t length;
} hll_location_entry;

// Table of locations used during compilation. Because of the nature of lisp,
// we want to allow using values from language to be used directly as AST,
// which makes embedding location info into values undesirable because
// of memory waste in most use cases.
// Instead, during compilation we create table of location infos,
// where each create object is mapped to its location using hash table
// which uses object pointers as hash values.
// Table is deleted just after the compilation finishes,
// using information from it to build mapping for bytecode instructions to
// source locations.
typedef struct {
  size_t hash_table[HLL_LOCATION_TABLE_SIZE];
  hll_location_entry *entries;
} hll_location_table;

typedef uint32_t hll_tu_flags;
enum { HLL_TU_FLAG_DEBUG = 0x1 };

// Meta information used in reader.
// It is named 'meta' because is not directly related to AST generation.
// This is used to build debug information that is later embedded into bytecode.
typedef struct {
  // Index of compilation unit in global table.
  uint32_t translation_unit;
  // Pointer to location table. Location table is populated during parsing,
  // and information stored in it is later used when building bytecode.
  hll_location_table *locs;
  const char *name;
  const char *source;
  struct hll_vm *vm;
  hll_tu_flags flags;
} hll_translation_unit;

hll_translation_unit hll_make_tu(struct hll_vm *vm, const char *source,
                                 const char *name, hll_tu_flags flags);
void hll_delete_tu(hll_translation_unit *tu);

// Kinds of tokens recognized by lexer.
typedef enum {
  HLL_TOK_EOF,
  HLL_TOK_NUM,
  HLL_TOK_SYMB,
  HLL_TOK_DOT,
  HLL_TOK_LPAREN,
  HLL_TOK_RPAREN,
  HLL_TOK_QUOTE,
  HLL_TOK_COMMENT,
  HLL_TOK_UNEXPECTED
} hll_token_kind;

// Token generated as result of lexing.
typedef struct {
  hll_token_kind kind;
  // offset from start of file. Can be used to generate line information
  size_t offset;
  // length of token in bytes
  uint32_t length;
  // Value of token if it is a number
  double value;
} hll_token;

// Lexer is designed in way it is possible to use outside of compiler to allow
// asy writing of tools like syntax highlighter and code formatter.
// Thus is does not act as a individual step of translation but as
// helper for reader.
typedef struct {
  // Used for error reporting. If NULL, no errors are reported
  hll_translation_unit *tu;
  // Mark that errors have been encountered during lexing.
  uint32_t error_count;
  // Current parsing location
  const char *cursor;
  // Input start. Used to calculate each token's offset
  const char *input;
  // Next peeked token. Stores result of lexing
  hll_token next;
} hll_lexer;

void hll_lexer_init(hll_lexer *lexer, const char *input,
                    hll_translation_unit *tu) __attribute__((nonnull(1, 2)));

// Generate next token and return it. If EOF is reached, EOF token is
// guaranteed to always be returned after that.
const hll_token *hll_lexer_next(hll_lexer *lexer) __attribute__((nonnull));

// Reader that generates AST using tokens generated by lexer. This structure
// is also commonly known as parser.
typedef struct {
  // Needed for error reporting and object allocations.
  hll_translation_unit *tu;
  // Mark that errors have been encountered during parsing.
  uint32_t error_count;
  // Lexer used for reading.
  // Reader process all tokens produced by lexer until EOF, so lifetime of
  // this lexer is associated with reader.
  hll_lexer *lexer;
  // Last token generated by lexer. This is shortcut not to access it through
  // lexer every time. This is pointer to 'next' field of lexer.
  const hll_token *token;
  // Internal flag used in lexer. Used for generating 'peek-eat' workflow
  // during reading.
  bool should_return_old_token;
} hll_reader;

// Initialized reader to use given lexer. Lexer is taken as pointer to allow
// used decide where it comes from.
void hll_reader_init(hll_reader *reader, hll_lexer *lexer,
                     hll_translation_unit *tu) __attribute__((nonnull(1, 2)));

// Reads whole ast tree.
hll_value hll_read_ast(hll_reader *reader) __attribute__((nonnull));

typedef struct {
  uint32_t cu;
  uint32_t offset;
  uint32_t length;
} hll_compiler_loc_stack_entry;

// Structure that holds state of compiler.
typedef struct {
  uint32_t error_count;

  // Bytecode that is currently being generated.
  struct hll_bytecode *bytecode;

  // Stack of locations compiler maintains. It is used to generate RLE-encoded
  // location information embedded in bytecode.
  hll_compiler_loc_stack_entry *loc_stack;
  // Compilation unit information. This decides whether to add location
  // information to generated bytecode or not.
  hll_translation_unit *tu;
  // Counter of first insruction in current RLE group (instructions that refer
  // to same location). It is updated when the loc_stack is changed.
  size_t loc_op_idx;
} hll_compiler;

void hll_compiler_init(hll_compiler *compiler, hll_translation_unit *tu)
    __attribute__((nonnull(1)));

// Compiles ast into a function object. Garbage collection is forbidden to
// happen during execution of this function.
hll_value hll_compile_ast(hll_compiler *compiler, hll_value ast)
    __attribute__((nonnull));

// Compiles hololisp code as a hololisp bytecode.
// Returns true on success, false otherwise.
// writes resulting function to location pointed by 'compiled' parameter.
// If function does not success, contents of memory pointed by 'compiled'
// are not defined.
bool hll_compile(struct hll_vm *vm, const char *source, const char *name,
                 hll_value *compiled) __attribute__((nonnull));

#endif
