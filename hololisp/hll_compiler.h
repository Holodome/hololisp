//
// hll_compiler.h
//
// This file contains lexer, parser and compiler definitions for use with
// hololisp.
//
// Lexer accepts c string of input and produces sequence of tokens.
// Lexer uses FSM internally and is able to generate tokens on demand
// one-by-one.
//
// Parser uses naive recursive-descent algorithm and produces tree of lisp
// objects, like lists.
//
// Compiler takes tree of tokens that can either be result of parsing or come
// from some other source, like be result of compilation.
// Compiler produces lisp function object that contains compiled lisp code
// generated from input.
//
// Despite lexer and parser being embedded and used only in intermediate
// step before compiling, they are made public for more usability.
//
#ifndef HLL_COMPILER_H
#define HLL_COMPILER_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "hll_hololisp.h"

// Kinds of tokens recognized by lexer.
enum hll_token_kind {
  // End of file
  HLL_TOK_EOF,
  // Number
  HLL_TOK_NUM,
  // Symbol
  HLL_TOK_SYMB,
  // .
  HLL_TOK_DOT,
  // (
  HLL_TOK_LPAREN,
  // )
  HLL_TOK_RPAREN,
  // '
  HLL_TOK_QUOTE,
  // Comment
  HLL_TOK_COMMENT,
  // Unexpected sequence of tokens. Eats all symbols in row.
  HLL_TOK_UNEXPECTED
};

// Token generated as result of lexing.
struct hll_token {
  enum hll_token_kind kind;
  // offset from start of file. Can be used to generate line information
  uint32_t offset;
  // length of token in bytes
  uint32_t length;
  // Value of token if it is a number
  double value;
};

// Lexer is designed in way it is possible to use outside of compiler to allow
// asy writing of tools like syntax highlighter and code formatter.
// Thus is does not act as a individual step of translation but as
// helper for reader.
struct hll_lexer {
  // Used for error reporting. If NULL, no errors are reported
  struct hll_vm *vm;
  // Mark that errors have been encountered during lexing.
  uint32_t error_count;
  // Current parsing location
  const char *cursor;
  // Input start. Used to calculate each token's offset
  const char *input;
  // Next peeked token. Stores result of lexing
  struct hll_token next;
};

// Initializes lexer to work on given buffer.
// vm can be null.
void hll_lexer_init(struct hll_lexer *lexer, const char *input,
                    struct hll_vm *vm) __attribute__((nonnull(1, 2)));

// Generate next token and return it. If EOF is reached, EOF token is
// guaranteed to always be returned.
const struct hll_token *hll_lexer_next(struct hll_lexer *lexer);

// Reader that generates AST using tokens generated by lexer. This structure
// is also commonly known as parser.
struct hll_reader {
  // Needed for error reporting and object allocations.
  struct hll_vm *vm;
  // Mark that errors have been encountered during parsing.
  uint32_t error_count;
  // Lexer used for reading.
  // Reader process all tokens produced by lexer until EOF, so lifetime of
  // this lexer is associated with reader.
  struct hll_lexer *lexer;
  // Last token generated by lexer. This is shortcut not to access it through
  // lexer every time. This is pointer to 'next' field of lexer.
  const struct hll_token *token;
  // Internal flag used in lexer. Used for generating 'peek-eat' workflow
  // during reading.
  bool should_return_old_token;
};

// Initialized reader to use given lexer. Lexer is taken as pointer to allow
// used decide where it comes from.
void hll_reader_init(struct hll_reader *reader, struct hll_lexer *lexer,
                     struct hll_vm *vm) __attribute__((nonnull));
// Reads whole ast tree.
hll_value hll_read_ast(struct hll_reader *reader);

struct hll_compiler {
  struct hll_vm *vm;
  bool has_errors;
  hll_value env;
  struct hll_bytecode *bytecode;
};

void hll_compiler_init(struct hll_compiler *compiler, struct hll_vm *vm,
                       hll_value env);
hll_value hll_compile_ast(struct hll_compiler *compiler, hll_value ast);

// Compiles hololisp code as a hololisp bytecode.
// Because internally lisp is represented as a tree of conses (lists),
// we first transform code into lisp AST and then by traversing it compile it.
// Though it is possible to compile simple code using stack-based traversal of
// tree instead of compiling it to AST it the first place, but lisp is
// different from other simple languages that it has macro system. Macros
// operate on AST, thus we have to go through the AST step.
bool hll_compile(struct hll_vm *vm, const char *source, hll_value *compiled);

#endif
